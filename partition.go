package sif

// A Partition is a portion of a columnar dataset, consisting of multiple Rows.
// Partitions are not generally interacted with directly, instead being
// manipulated in parallel by DataFrame Tasks.
type Partition interface {
	ID() string            // ID retrieves the ID of this Partition
	GetMaxRows() int       // GetMaxRows retrieves the maximum number of rows in this Partition
	GetNumRows() int       // GetNumRows retrieves the number of rows in this Partition
	GetRow(rowNum int) Row // GetRow retrieves a specific row from this Partition
}

// A BuildablePartition can be built. Used in the implementation of DataSources and Parsers
type BuildablePartition interface {
	Partition
	ForEachRow(fn MapOperation) error                                                                                                // ForEachRow iterates over Rows in a Partition
	AppendEmptyRowData(tempRow Row) (Row, error)                                                                                     // AppendEmptyRowData is a convenient way to add an empty Row to the end of this Partition, returning the Row so that Row methods can be used to populate it
	AppendRowData(row []byte, meta []byte, varData map[string]interface{}, serializedVarRowData map[string][]byte) error             // AppendRowData adds a Row to the end of this Partition, if it isn't full and if the Row fits within the schema
	InsertRowData(row []byte, meta []byte, varRowData map[string]interface{}, serializedVarRowData map[string][]byte, pos int) error // InsertRowData inserts a Row at a specific position within this Partition, if it isn't full and if the Row fits within the schema. Other Rows are shifted as necessary.
	TruncateRowData(numRows int)                                                                                                     // TruncateRowData zeroes out rows from the current last row towards the beginning of the Partition
	CreateTempRow() Row                                                                                                              // Creates a temporary Row struct which is not backed by the underlying data model of this Partition, for use with other methods as an allocation efficiency booster
}

// A KeyablePartition can be keyed. Used in the implementation of Partition shuffling and reduction
type KeyablePartition interface {
	KeyRows(kfn KeyingOperation) (OperablePartition, error) // KeyRows generates hash keys for a row from a key column. Attempts to manipulate partition in-place, falling back to creating a fresh partition if there are row errors
}

// An OperablePartition can be operated on
type OperablePartition interface {
	Partition
	KeyablePartition
	UpdateSchema(currentSchema Schema)                            // Sets the public schema of a Partition
	MapRows(fn MapOperation) (OperablePartition, error)           // MapRows runs a MapOperation on each row in this Partition, manipulating them in-place. Will fall back to creating a fresh partition if PartitionRowErrors occur.
	FlatMapRows(fn FlatMapOperation) ([]OperablePartition, error) // FlatMapRows runs a FlatMapOperation on each row in this Partition, creating new Partitions
	FilterRows(fn FilterOperation) (OperablePartition, error)     // FilterRows filters the Rows in the current Partition, creating a new one
	Repack(newSchema Schema) (OperablePartition, error)           // Repack repacks a Partition according to a new Schema
}

// A CollectedPartition has been collected
type CollectedPartition interface {
	Partition
	ForEachRow(fn MapOperation) error // ForEachRow iterates over Rows in a Partition
}

// A CloneablePartition is cloneable. Used in the implementation of Partition shuffling
type CloneablePartition interface {
	GetRowMeta(rowNum int) []byte                         // GetRowMeta retrieves specific row metadata from this Partition
	GetRowMetaRange(start int, end int) []byte            // GetRowMetaRange retrieves an arbitrary range of bytes from the row meta
	GetRowData(rowNum int) []byte                         // GetRowData retrieves a specific row from this Partition
	GetRowDataRange(start int, end int) []byte            // GetRowDataRange retrieves an arbitrary range of bytes from the row data
	GetVarRowData(rowNum int) map[string]interface{}      // GetVarRowData retrieves the variable-length data for a given row from this Partition
	GetSerializedVarRowData(rowNum int) map[string][]byte // GetSerializedVarRowData retrieves the serialized variable-length data for a given row from this Partition
	GetSchema() Schema                                    // GetSchema retrieves the Schema from the most recent task that manipulated this Partition
	GetIsKeyed() bool                                     // GetIsKeyed returns true iff this Partition has been keyed with KeyRows
	GetKey(rowNum int) (uint64, error)                    // GetKey returns the shuffle key for a row, as generated by KeyRows
	GetKeyRange(rowNum int, numRows int) []uint64         // GetKeyRange returns a range of shuffle keys for a row, as generated by KeyRows, starting at rowNum
}

// A ReduceablePartition can be stored in a PartitionIndex. Used in the implementation of Partition reduction
type ReduceablePartition interface {
	CloneablePartition
	BuildablePartition
	KeyablePartition
	PopulateTempRow(tempRow Row, idx int)
	FindFirstKey(key uint64) (int, error)                                          // PRECONDITION: Partition must already be sorted by key
	FindLastKey(key uint64) (int, error)                                           // PRECONDITION: Partition must already be sorted by key
	FindFirstRowKey(keyBuf []byte, key uint64, keyfn KeyingOperation) (int, error) // PRECONDITION: Partition must already be sorted by key
	FindLastRowKey(keyBuf []byte, key uint64, keyfn KeyingOperation) (int, error)  // PRECONDITION: Partition must already be sorted by key
	AverageKeyValue() (uint64, error)                                              // AverageKeyValue is the average value of key within this sorted, keyed Partition
	Split(pos int) (ReduceablePartition, ReduceablePartition, error)               // Split splits a Partition into two Partitions. Split position ends up in right Partition.
	BalancedSplit() (uint64, ReduceablePartition, ReduceablePartition, error)      // Split position ends up in right Partition.
	ToBytes() ([]byte, error)                                                      // ToBytes serializes a Partition to a byte array suitable for persistence to disk
}
